## 线程的生命周期
    创建线程对象  调用start去执行线程
      1.创建对象    调用start    2.就序状态（有了执行的资格,但是没有执行权）
      
      3.去抢占CPU执行权    得到了运行的资格（run() 如果我得到了运行资格之后 调用 stop() 
        当前如果抢到了CPU执行权  那么其他线程会不会来抢当前线程的执行权,如果被其他线程抢到了那么当前线程 又会开始走第二步
     
      4.线程死亡  线程对象变成了垃圾)      
        
       当线程遇到了阻塞 （Thread.Sleep(时间)，wait())  会走第二步 
        
        run() 和start()方法的区别?
        run方法单独在使用时候  就相当于普通方法
        start 在启动的时候 jvm去 调用   run方法
        
        
       
        synchronized 和 lock锁的区别？
        1.前者是自动上锁 自动解锁   后者  手动上锁 手动解锁
        2.前者有同步锁对象   后者没有岁对象
        3.前者有锁对象 可以通过调用 notify()   wait()  nofifyAll()  去控制线程
          后者不具有锁对象的   不可以去调用上诉方法
          
        如果在并发量很大的情况下   建议使用  lock      
        
        
        
        
          
          